# 1309. 동물원

# 2s, 128MB
# 2 * N칸 동물원 (N:10^5)

N = int(input())

# 3 * N칸 dp (10 01 00)
dp = [[0]*3 for _ in range(N)]
dp[0] = [1, 1, 1]

for i in range(1, N):

    dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % 9901     # L에만 넣을 때: 직전에 R에만 넣거나, 안 넣는 경우의 수를 더함
    dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901     # R에만 넣을 때: 직전에 L에만 넣거나, 안 넣는 경우의 수를 더함
    dp[i][2] = (sum(dp[i-1])) % 9901                # 안 넣을 때: 직전에 R에만 넣거나, L에만 넣거나, 안 넣는 경우의 수 전부 더함


# 마지막 값 전부 더하면 최종 경우의 수 (최종 sum이 9901을 넘을 수 있어서 한 번 더 나눠줌)
print(sum(dp[-1]) % 9901)

# 9901: 소수 (문제에서 임의로 지정)
# 모듈러 성질: 분배 법칙: (a+b)%m=((a%m)+(b%m))%m, (a×b)%m=((a%m)×(b%m))%m



# self-feedback
# 아이디어는 떠올렸는데 점화식으로 연결짓지 못함 .. 너무 아쉽다
# 다시 풀기